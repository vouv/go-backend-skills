进阶数据结构
bitmap、skiplist、B+Tree、Black-White-Tree

Vouv
https://github.com/vouv

# 关于

实际上，无数优秀架构设计的思想来源都是基础的数据结构和算法。

创新并非离我们很远，创新的源泉来自对事物本质的认识。

# 位图（bitmap）

使用场景：爬虫URL去重

布隆过滤器

# 跳表（skiplist）

# B+树（B+Tree）

# 红黑树（Red Black Tree）

红黑树是"近似平衡"的二叉树，"平衡"的意思可以等价为性能不退化。"近似平衡"就等价为性能不会退化的太严重。 红黑树有如下要求：

- 根节点是黑色的
- 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据
- 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的
- 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点

# 递归树（Recursion Tree）

递归代码的时间复杂度分析起来很麻烦，用递推公式的话，会涉及非常复杂的数学推导。

*递归树与时间复杂度分析*

*分析快速排序的时间复杂度*

快速排序在最好情况下，每次分区都能一分为二，这个时候用递推公式

```
T(n) = 2 * T(n/2) + n
```

很容易就能推导出时间复杂度是 O(nlogn)。但是，我们并不会每次分区都这么幸运。

假设平均情况下，每次分区之后，两个分区的大小比例为 1:k。当 k=9 时，如果用递推公式的方法来求解时间复杂度的话，递推公式就写成

```
T(n) = T(n/10) + T(9n/10) + n
```

从概率论的角度来说，快排的平均时间复杂度就是 O(nlogn)。

# Trie树

Trie树，也叫字典树。顾名思义，它是一个树形结构。它是一种专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。Trie树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起

*思考*

在Trie树查找字符串的时间复杂度？

构建 Trie 树的过程，需要扫描所有的字符串，时间复杂度是 O(n)，n 表示所有字符串的长度和。

而构建好 Trie 树后，在其中查找字符串的时间复杂度是 O(k)，k 表示要查找的字符串的长度。

*Trie*树缺点*

1. 字符串中包含的字符集不能太大。我们前面讲到，如果字符集太大，那存储空间可能就会浪费很多。即便可以优化，但也要付出牺牲查询、插入效率的代价。
2. 要求字符串的前缀重合比较多，不然空间消耗会变大很多。
3. 如果要用Trie树解决问题，那我们就要自己从零开始实现一个Trie树，这个在工程上是将简单问题复杂化，除非必须，一般不建议这样做。
4. 我们知道，通过指针串起来的数据块是不连续的，而 Trie 树中用到了指针，所以，对缓存并不友好，性能上会打个折扣。

.play algo/advanced/trie-tree.go

# AC自动机（Aho-Corasick）

场景：实现一个高性能的敏感词过滤系统。

Trie树跟AC自动机之间的关系，就像单串匹配中朴素的串匹配算法，跟 KMP 算法之间的关系一样，只不过前者针对的是多模式串而已。

所以，AC 自动机实际上就是在 Trie 树之上，加了类似 KMP 的 next 数组，只不过此处的 next 数组是构建在树上罢了。

*基于单模式串和Trie树实现的敏感词过滤*

# Disruptor

todo

# A*搜索算法

todo

# 拓扑排序

todo



