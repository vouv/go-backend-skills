基础数据结构
数组、链表、栈、队列、图

Vouv
https://github.com/vouv

# 数组

数组寻址公式

```
a[i]_address = base_address + i * data_type_size
```

插入与删除时间复杂度：O(n)

## 思考

### 1. 为什么多数编程语言数组下标从0开始？

如果从1开始，那么随机访问的寻址公式会变成如下

```
a[i]_address = base_address + (i-1)*type_size
```

每次随机访问数组元素对于 CPU 来说，就多了一次减法指令。另外从历史原因说，C语言设计者设计从0开始，导致其他语言效仿。

.play algo/basic/array.go

# 链表

链表与数组的区别

- 数组在内存中是以连续空间存储，链表使用零散的空间
- 链表在插入删除操作的时间复杂度是O(1)，比数组高效

### 单链表

每个链表节点只包含一个指向后续节点的指针 Next。

### 双向链表

每个链表节点出来包含一个指向后续节点的指针 Next 外， 还有指向前驱节点的指针 Prev 。

### 循环链表

链表的尾节点后续指针指向头节点，整个链表形成一个环

## 思考

### 1. 给定一个链表，链表中形成了一个环，如何找到环的入口节点？

.play algo/basic/linkedlist.go

# 栈

当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选栈。栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈叫作顺序栈，用链表实现的栈叫作链式栈。

## 思考

### 1. 实现浏览器的前进和后退功能？
### 2. 如何实现一个带有Min()函数的栈，要求以O(1)时间复杂度获取栈中最小值？
### 3. 栈在表达式求值中的应用? 栈在括号匹配中的应用？

.play algo/basic/stack.go

# 队列

先进者先出，这就是典型的队列。与栈类似，数组实现的队列叫顺序队列，用链表实现的队列叫链式队列。对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过队列来实现请求排队（如线程池）。

*阻塞队列*

阻塞队列其实就是在队列基础上增加了阻塞操作，在队列为空的时候，从队头取数据会被阻塞。在实际的软件工程中，阻塞队列就是一个生产者 - 消费者模型。

*并发队列*

线程安全的队列我们叫并发队列，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。

## 思考

### 1. 队列在线程池等有限资源池中的应用？

.play algo/basic/queue.go

# 散列表

散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实是数组的一种扩展，由数组演化而来。可以说没有数组就没有散列表。

## 散列函数

顾名思义，是一个函数。我们可以把它定义成 hash(key)，hash(key) 的返回值表示经过散列函数计算得到的散列值。

散列函数设计的基本要求：

- 1. 散列函数计算得到的散列值是一个非负整数
- 2. 若 key1 = key2，则 hash(key1) == hash(key2)
- 3. 若 key1 ≠ key2，则 hash(key1) ≠ hash(key2)

## 散列冲突

业界著名的MD5、SHA、CRC等哈希算法，也无法完全避免这种散列冲突，因为散列后的空间是有限的。

散列冲突解决方法有两类，开放寻址法（open addressing）和链表法（chaining）。

*如何设计一个工业级散列表*

要求：

- 支持快速的查询、插入、删除操作；
- 内存占用合理，不能浪费过多的内存空间；
- 性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况

思路：

- 设计一个合适的散列函数（Go-map实现中散列值分为高低位的策略）
- 定义装载因子阈值，并且设计动态扩容策略
- 选择合适的散列冲突解决方法（如Java LinkedHashMap使用红黑树的例子）

*LRU缓存淘汰算法*

如果单纯用链表实现的LRU缓存淘汰算法，它的时间复杂是O(n)。如果结合散列表和链表进行实现，就能把时间复杂度降到O(1)。

.play algo/basic/hash.go

# 树

*节点的高度*：节点到叶子节点的最长路径（边数）

*节点的深度*：根节点到这个节点经历边的个数

*节点的层数*：节点深度 + 1

*树的高度*：根节点的高度

.image /content/img/algo/tree.jpg 0 500

*满二叉树*：除了叶子节点之外，每个节点都有左右两个子节点

*完全二叉树*：除了最后一层，其他层的节点个数都达到最大，且最后一层的叶子节点都靠左排列

*前序遍历*：对树中的任意节点，先打印这个节点，然后再打印左子树，最后打印右子树

*中序遍历*：对树中的任意节点，先打印左子树，然后再打印这个节点，最后打印右子树

*后序遍历*：对树中的任意节点，先打印左子树，然后再打印右子树，最后打印这个节点

.play algo/basic/tree.go

# 二叉查找树

*定义*：对树中的任意一个节点，其左子树中的每个节点的值，都小于这个节点的值，而右子树节点的值都大于这个节点的值

*支持重复数据*

可以通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。

.play algo/basic/tree.go

# 堆

- 堆是一个完全二叉树
- 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值

## 堆化

从下往上的堆化代码结构如下

从上往下的堆化代码结构如下

.play algo/basic/heap.go

# 图







