排序
冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序

Vouv
https://github.com/vouv

# 常用排序算法

冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序

## 如何分析排序算法

1. 最好情况、最坏情况、平均情况时间复杂度

2. 时间复杂度的系数、常数 、低阶

3. 比较次数和交换（或移动）次数

4. 排序算法的内存消耗和稳定性（稳定的排序算法与不稳定的排序算法）

.play algo/sorts/interface.go

# 冒泡排序

冒泡排序只会比较相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较交换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

在实现中有一种提高效率的方式，就是设置一个标志位，在一趟扫描中如果没有发生数据交换就表示排序结束了。

## 思考

### 1. 冒泡排序是原地排序算法吗？

它的空间复杂度为 O(1)，是一个原地排序算法。

### 2. 冒泡排序是稳定的排序算法吗？

当有相邻的两个元素大小相等的时候，我们不做交换，所以冒泡排序是稳定的排序算法。

### 3. 冒泡排序的时间复杂度是多少？

最好情况时间复杂度是 O(n)，最坏情况时间复杂度为 O(n²），平均情况时间复杂度为 O(n²)。

.play algo/sorts/bubble_sort.go
.play algo/sorts/bubble_sort_1.go
.play algo/sorts/bubble_sort_2.go

# 插入排序

插入排序算法将数组分为已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。

插入排序代码在SDK `sort/sort.go` 文件内有典型的实现

## 思考

### 1. 插入排序是原地排序算法吗？

它的空间复杂度为 O(1)，是一个原地排序算法。

### 2. 插入排序是稳定的排序算法吗？

插入排序对于值相同的元素，选择将后面出现的元素，插入到前面元素的后面，所以是稳定的排序算法。

### 3. 插入排序的时间复杂度是多少？

最好情况时间复杂度是 O(n)，最坏情况时间复杂度为 O(n²)，平均情况时间复杂度为 O(n²)。

.play algo/sorts/insertion_sort.go

# 选择排序

与插入排序类似，选择排序也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

## 思考

### 1. 选择排序是原地排序算法吗？

空间复杂度为 O(1)，是一个原地排序算法。

### 2. 选择排序是稳定的排序算法吗？

不是，选择排序每次都要找未排序元素中的最小值，并和前面的元素交换位置，破坏了稳定性。

### 3. 选择排序的时间复杂度是多少？

最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n²)，所以相对于冒泡排序和插入排序，选择排序就稍微逊色了。

## 小结

冒泡排序、插入排序、选择排序这三种排序算法，它们的时间复杂度都是 O(n²)，比较高，适合小规模数据的排序，因此实际中应用并不多。

.play algo/sorts/selection_sort.go

# 归并排序

归并排序的核心思想是先把数组从中间分成前后两部分，对前后两部分分别排序，最后再将排好序的两部分合并在一起，其实就是分治思想。

## 思考

### 1. 归并排序是稳定的排序算法吗？

归并排序合并的时候可以先把之前的元素放入数组，所以是稳定的排序算法。

### 2. 归并排序的时间复杂度是多少？

不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)。

### 3. 归并排序的空间复杂度是多少？

归并排序不是原地排序算法，空间复杂度是 O(n)。

.play algo/sorts/merge_sort.go

# 快速排序

快排在数组中选取任意一个数据作为 pivot（分区点），然后遍历数组，把小于 pivot 的放到左边，大于 pivot 的放到右边，直到数组区间缩小为1。

## 性能分析

快排的平均时间复杂度也是 O(nlogn)，但是这取决于我们选择的分区点的位置，如果每次选择的分区点在两端，复杂度退化为O(n²)。

快排复杂度在于分区点的选择，常用的方式有3数取中，多数取中，另外，根据 `sort/sort.go` 源码，GO官方在实现快排的时候还考虑到了数组中有大量元素的情况，对应的解决办法是从分区点向左右两端移动，跳过重复元素，从而达到缩小左右子区间的效果。

.play algo/sorts/quick_sort.go

# 堆排序

堆：是一个完全二叉树，每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。

堆排序是一种原地的、时间复杂度为 O(nlogn) 的排序算法，其中堆化操作的时间复杂度是 O(logn)。

## 思考

### 1. 在时间复杂度上，堆排序比快排还要稳定，为什么在实际开发中快排的性能比堆排序好？。

首先，堆排序数据访问的方式没有快速排序友好，快排顺序访问数据，堆排序跳着访问，对CPU缓存极不友好。

其次，对于同样的数据，快排数据交换的次数不会比逆序度多，堆排序建堆会打乱原始数据有序度，所以堆排序交换次数普遍比快排多。

.play algo/sorts/heap_sort.go

# 线性排序 - 桶排序

桶排序的核心思想是将数据分到几个有序的桶里，每个桶里的数据再单独进行排序，最后把每个桶里的数据按照顺序依次取出，组成的序列就是有序的，另外，桶排序比较适合于外部排序。

## 分析

如果有n个数据，把它们均匀地划分到m个桶内，每个桶里就有k=n/m个元素。每个桶内部使用快速排序，时间复杂度为 O(klogk)。

则m个桶排序的时间复杂度就是 O(m * k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n * log(n/m))。

当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。

.play algo/sorts/bucket_sort.go

# 线性排序 - 计数排序

计数排序其实是桶排序的一种特殊情况，需要注意的是计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数，比如统一增加一个数使得全部数据都大于0。

.play algo/sorts/counting_sort.go

# 线性排序 - 基数排序

场景：假设有10万个手机号码，要将这10万个手机号码从小到大排序，使用基数排序比较合适。

## 分析

基数排序对要排序的数据是有要求的，需要可以分割出独立的位来比较，而且位之间有递进的关系，例如手机号的例子。

除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则基数排序的时间复杂度就无法达到 O(n) 了。

.play algo/sorts/radix_sort.go