字符串匹配
BF、RK、BM、KMP

Vouv
https://github.com/vouv

# BF（Brute Force）

暴力匹配算法，也叫朴素匹配算法， 是最简单、最暴力的字符串匹配算法。

BF 算法的思想是在主串中，分别匹配起始位置分别是 0、1、2…n-m 且长度为 m 的 n-m+1 个子串。

*思考*

为什么理论上BF算法的时间复杂度很高，是 O(n*m)，但在实际的开发中，它却是一个比较常用的字符串匹配算法？

1. 实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长

2. BF算法思想简单，实现也简单，根据[[https://zh.wikipedia.org/wiki/KISS%E5%8E%9F%E5%88%99][KISS原则]]，简单是首选。

.play algo/string/bf.go

# RK（Rabin-Karp）

BF算法的时间复杂度是 O(n*m)。如果对BF算法稍加改造，子串比较使用哈希算法，时间复杂度立刻就会降低。

主要思路：通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。

*哈希算法构造*

为了位避免哈希冲突，考虑到字符集和n进制表示法，设计方法如下

```
"123" = 1 * 10 * 10 + 2 * 10 + 3 = 123

"cba" = 3 * 26 * 26 + 2 * 26 + 1 = 1353
```

*时间复杂度分析*

模式串哈希值与每个子串哈希值之间的比较的时间复杂度是 O(1)，总共需要比较 n-m+1 个子串的哈希值，所以，这部分的时间复杂度也是 O(n)。

所以，RK 算法整体的时间复杂度是 O(n)。但是字符集很大的话计算出的哈希值也很大

.play algo/string/rk.go

# BM（Boyer-Moore）

BM算法是一种非常高效的字符串匹配算法，有实验统计，它的性能是著名的KMP算法的 3 到 4 倍。

BM算法包含两部分规则：坏字符规则（bad character rule）和好后缀规则（good suffix shift）。

*坏字符规则*

*好后缀规则*

.play algo/string/bm.go

# KMP（Knuth Morris Pratt）

KMP算法的核心思想，和BM算法非常相近，类似 BM 算法中的 bc、suffix、prefix 数组。

KMP 算法也可以提前构建一个数组，用来存储模式串中每个前缀（这些前缀都有可能是好前缀）的最长可匹配前缀子串的结尾字符下标。

我们把这个数组定义为 next 数组，很多书中把这个数组叫失效函数（failure function）。

*失效函数计算方法*

todo

*复杂度分析*

KMP 算法只需要一个额外的 next 数组，数组的大小跟模式串相同。所以空间复杂度是 O(m)，m 表示模式串的长度。

KMP 算法的时间复杂度是 O(m+n)。

.play algo/string/kmp.go