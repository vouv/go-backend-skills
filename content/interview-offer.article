剑指Offer
名企面试官精讲典型编程题

Vouv
https://github.com/vouv

# 面试题03. 数组中重复的数字

找出数组中重复的数字。

在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

### 示例:

```
输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3
```

### 限制:

```
2 <= n <= 100000
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof

## Solution

1. 数字都在 0～n-1 的范围, 可以利用数组下标来保存这个数是否存在过，这里有个巧妙的办法，就是把对应数组下标的数设置为负数。
2. 扫描过程中把nums[i] 放到 nums[nums[i]] 的位置，放之前判断，如果该位置已经有则表示重复。

.play interview/offer/03-abs.go
.play interview/offer/03-swap.go

# 面试题04. 二维数组中的查找

在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

### 示例:

现有矩阵 matrix 如下：

```
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
```

给定 target = `5` ，返回 `true` 。

给定 target = `20` ，返回 `false` 。

### 限制:

```
0 <= n <= 1000
0 <= m <= 1000
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof

## Solution

从右上角或左下角开始找，每次比较都能排除一行或一列，但是从左上角或右下角就不行。

.play interview/offer/04.go

# 面试题05. 替换空格

请实现一个函数，把字符串 `s` 中的每个空格替换成 `"%20"` 。

### 示例:

```
输入：s = "We are happy."
输出："We%20are%20happy."
```

### 限制:

```
0 <= s 的长度 <= 10000
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof

## Solution

先遍历一遍字符串，统计空格的数量，再根据字符串长度和空格数量计算申请出所需内存空间，之后遍历填入即可。

.play interview/offer/05.go

# 面试题06. 从尾到头打印链表

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

### 示例:

```
输入：head = [1,3,2]
输出：[2,3,1]
```

### 限制:

```
0 <= 链表长度 <= 10000
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof

## Solution

从尾到头符合一个后进先出的趋势，于是想到用栈，而递归调用是使用栈的经典方式。

.play interview/offer/06.go

# 面试题07. 重建二叉树

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

例如:

```
给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]

返回如下的二叉树：

  3
 / \
9  20
  /  \
 15   7
```

### 限制:

```
0 <= 节点个数 <= 5000
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof

## Solution

解决此题时要充分了解二叉树前序遍历序列和中序遍历序列的特征：

- 前序遍历序列第一个节点就是根节点
- 而中序遍历序列中根节点的左侧就是左子树的中序序列，同时也可以根据长度将左子树的映射到前序序列中根节点的右侧。

.play interview/offer/07.go

# 面试题09. 用两个栈实现队列

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )

### 示例1:

```
输入：
["CQueue","appendTail","deleteHead","deleteHead"]
[[],[3],[],[]]
输出：[null,null,3,-1]
```

### 示例2:

```
输入：
["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]
[[],[],[5],[2],[],[]]
输出：[null,-1,null,null,5,2]
```

### 提示:

```
1 <= values <= 10000
最多会对 appendTail、deleteHead 进行 10000 次调用
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof

## Solution

栈符合后进先出的特性，队列则是先进先出。两个栈一个用于入栈，一个用于出栈即可解决问题。

- 入队操作：将元素压如栈A
- 出队操作：如果栈B不为空，栈B出栈；如果栈B为空，将栈A所有元素按出栈顺序出栈并压入B，再执行栈B出栈操作

.play interview/offer/09.go

# 面试题10-I. 斐波那契数列

写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：

```
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
```

斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

### 示例1:

```
输入：n = 2
输出：1
```

### 示例2:

```
输入：n = 5
输出：5
```

### 提示:

```
0 <= n <= 100
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof

## Solution

使用从0开始顺序求值的方式，如果使用从上往下递归的方式会导致重复计算。

.play interview/offer/10-1.go

# 面试题10-II. 青蛙跳台阶问题

一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

### 示例1:

```
输入：n = 2
输出：2
```

### 示例2:

```
输入：n = 7
输出：21
```

### 提示:

```
0 <= n <= 100
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof

## Solution

实际上是斐波那契数列变体，只是第一项变为1。

.play interview/offer/10-2.go

# 面试题11. 旋转数组的最小数字

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  

### 示例1:

```
输入：[3,4,5,1,2]
输出：1
```

### 示例2:

```
输入：[2,2,2,0,1]
输出：0
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof

## Solution

使用二分查找的思想，重点是在二分查找的每一步，如何根据 nums[mid] 的值确定下一步的搜索区间。

- numbers[mid] >  numbers[hi] : 左边区间排除，下一步搜索区间 [mid+1:hi]
- numbers[mid] >  numbers[hi] : 右边区间排除，mid点可能为最小，下一步搜索区间 [lo:mid]
- numbers[mid] == numbers[hi] : 不能确定左右区间，但是 numbers[hi] 能排除，下一步搜索区间 [lo:hi-1]

.play interview/offer/11.go

# 面试题12. 矩阵中的路径

请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。

```
[["a","b","c","e"],
["s","f","c","s"],
["a","d","e","e"]]
```

但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。

### 示例1:

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]],
word = "ABCCED"
输出：true
```

### 示例2:

```
输入：board = [["a","b"],["c","d"]], word = "abcd"
输出：false
```

### 提示:

```
1 <= board.length <= 200
1 <= board[i].length <= 200
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof

## Solution

BFS与回溯。

.play interview/offer/12.go

# 面试题13. 机器人的运动范围

地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

*示例1：*

```
输入：m = 2, n = 3, k = 1
输出：3
```

*示例2：*

```
输入：m = 3, n = 1, k = 0
输出：1
```

*提示：*

```
1 <= n,m <= 100
0 <= k <= 20
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof

## Solution

回溯法的思路，从（0，0）开始对四个方向进行回溯，当它准备进入（i，j）适，判断是否可以进入，之后搜索相邻四个方向的格子即可。

.play interview/offer/13.go

# 面试题14-I. 剪绳子I

给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m] 。请问 k[0]*k[1]*...*k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

### 示例1:

```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
```

### 示例2:

```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
```

### 提示:

```
2 <= n <= 58
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/jian-sheng-zi-lcof

## Solution

1. 根据分析可以知道，应该尽可能把数拆成多个3，当数小于5时拆解办法是固定的，所以当数大于5的时候一直拆解到3或4或5即可。

.play interview/offer/14-1.go

# 面试题14-II. 剪绳子II

给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 `k[0],k[1]...k[m]` 。请问 `k[0]*k[1]*...*k[m]` 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

### 示例1:

```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
```

### 示例2:

```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
```

### 提示:

```
2 <= n <= 1000
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof

## Solution

解题方式类似上题。

.play interview/offer/14-2.go

# 面试题15. 二进制中1的个数

请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。

### 示例1:

```
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
```

### 示例2:

```
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
```

### 示例3:

```
输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```

来源：力扣（LeetCode）

链接1：https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof

链接2：https://leetcode-cn.com/problems/number-of-1-bits/

## Solution

这里需要知道一条规律：一个非0的数与它减去1做与运算会消除掉原数二进制串中的一个1，重复操作消除到0为止统计的次数就是1的数量。

.play interview/offer/15.go

# 面试题16. 数值的整数次方

实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。

### 示例1:

```
输入: 2.00000, 10
输出: 1024.00000
```

### 示例2:

```
输入: 2.10000, 3
输出: 9.26100
```

### 示例3:

```
输入: 2.00000, -2
输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25
```

### 说明:

```
-100.0 < x < 100.0
n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof

## Solution

二分法，每次都把幂次n降为一半，对于基数次幂还需要考虑到余项的问题，用递归就可以简单的描述出来。

- n * 2 : 想到 n << 1
- n / 2 : 想到 n >> 1
- n % 2 : 想到 n & 1

.play interview/offer/16.go

# 面试题17. 打印从1到最大的n位数

输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。

### 示例1:

```
输入: n = 1
输出: [1,2,3,4,5,6,7,8,9]
```

### 说明:

```
用返回一个整数列表来代替打印
n 为正整数
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof

## Solution

其实这里题目要表达的坑是处理大数问题，第一个解法由于输出int类型，无法体现出坑点；第二个解法使用回溯法构造数字字符串，构造过程中需要注意前缀'0'问题。

.play interview/offer/17-simple.go
.play interview/offer/17-bt.go

# 面试题18. 删除链表的节点

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

注意：此题对比原题有改动

### 示例1:

```
输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
```

### 示例2:

```
输入: head = [4,5,1,9], val = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.
```

### 说明:

```
题目保证链表中节点的值互不相同
若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof

## Solution

使用双指针的办法，一个指针在前，用于记录需要删除节点的前驱节点。

考虑到输入为空或者删除第一个节点的情况，引入dummyHead。

.play interview/offer/18.go

# 面试题19. 正则表达式匹配

请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a"均不匹配。

### 示例1:

```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

### 示例2:

```
输入:
s = "aa"
p = "a*"
输出: true
解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
```

### 示例3:

```
输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
```

### 示例4:

```
输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
```

### 示例5:

```
输入:
s = "mississippi"
p = "mis*is*p*."
输出: false

s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof

## Solution

有限状态机的思路，每次从s中拿出一个字符和p中的字符去匹配。

- 如果p中第二个字符是'*'，会有几种匹配模式，可以直接忽略（字符相等或不等时，匹配0次），或匹配一次（字符相等时，s后移1位），或匹配一次（字符相等时，s后移1位,p后移2位）
- 如果p中第二个字符不是'*'，直接判断是否可匹配即可

.play interview/offer/19.go

# 面试题20. 表示数值的字符串

请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100"、"5e2"、"-123"、"3.1416"、"0123"及"-1E-16"都表示数值，但"12e"、"1a3.14"、"1.2.3"、"+-5"及"12e+5.4"都不是。

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof

## Solution

依然是状态转换的思想，模式如下：

```
[sign] digit [.[ digits ]] [e|E [sign] digits ]
```

.play interview/offer/20.go

# 面试题21. 调整数组顺序使奇数位于偶数前面

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

### 示例:

```
输入：nums = [1,2,3,4]
输出：[1,3,2,4]
注：[3,1,2,4] 也是正确的答案之一。
```

### 提示:

```
1 <= nums.length <= 50000
1 <= nums[i] <= 10000
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof

## Solution

联想到快速排序中的 partition 函数，稍作修改即可满足题目要求。

.play interview/offer/21.go

# 面试题22. 链表中倒数第k个节点

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。

### 示例:

```
给定一个链表: 1->2->3->4->5, 和 k = 2.
返回链表 4->5.
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof

## Solution

双指针 p 和 q ，q 指针先走 k 步，然后 p 和 q 同时向后走，当 q 走的末尾时， p就是倒数第 k 个节点。

.play interview/offer/22.go

# 面试题24. 反转链表

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

### 示例:

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

### 限制:

```
0 <= 节点个数 <= 5000
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof

## Solution

```
时间复杂度：O(n)
空间复杂度：O(1)
```

设置一个新表头，用来指向反转后的表头，依次遍历输入链表，每遍历一个节点就把节点插入到新链表表头。

.play interview/offer/24.go

# 面试题25. 合并两个排序的链表

输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。

### 示例1:

```
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```

### 限制:

```
0 <= 链表长度 <= 1000
```
来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof

## Solution

使用递归的方法，遍历两个链表，每次取值较小的节点拼接，对后面的节点依次递归即可。

.play interview/offer/25.go

# 面试题26. 树的子结构

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

例如:

```
给定的树 A:

     3
    / \
   4   5
  / \
 1   2

给定的树 B：

   4 
  /
 1

返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。
```

### 示例1:

```
输入：A = [1,2,3], B = [3,1]
输出：false
```

### 示例2:

```
输入：A = [3,4,5,1,2], B = [4,1]
输出：true
```

### 限制:

```
0 <= 节点个数 <= 10000
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof

## Solution

使用递归去依次比较树的子结构节点即可。

.play interview/offer/26.go

# 面试题27. 二叉树的镜像

请完成一个函数，输入一个二叉树，该函数输出它的镜像。

例如:

```
输入:

     4
   /   \
  2     7
 / \   / \
1   3 6   9

镜像:

输出:

     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

### 示例1:

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

### 限制:

```
0 <= 节点个数 <= 1000
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof

## Solution

```
时间复杂度：O(n)
空间复杂度：O(1)
```

虽说二叉树镜像看起来像新概念，了解后其实很简单，对于一个节点，将它的左右子树交换，对子树递归地操作到最后就完成了。

.play interview/offer/27.go

# 面试题28. 对称的二叉树

请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。

例如：

```
二叉树 [1,2,2,3,4,4,3] 是对称的。

    1
   / \
  2   2
 / \ / \
3  4 4  3

但是：

这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

  1
 / \
2   2
 \   \
  3   3
```

### 示例1:

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

### 示例2:

```
输入：root = [1,2,2,null,3,null,3]
输出：false
```

### 限制:

```
0 <= 节点个数 <= 1000
```
来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof

## Solution

todo


.play interview/offer/28.go

# 面试题29. 顺时针打印矩阵

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

### 示例1:

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

### 示例2:

```
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

### 限制:

```
0 <= matrix.length <= 100
0 <= matrix[i].length <= 100
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof

## Solution

使用设立上下左右边界的方式，从四个不同方向依次遍历矩阵。

.play interview/offer/29.go

# 面试题30. 包含min函数的栈

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

### 示例:

```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.min();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.min();   --> 返回 -2.
```

### 提示:

```
各函数的调用总次数不超过 20000 次
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof

## Solution

考虑到栈的压入或弹出操作后都对应一个状态，且也有后进先出的特性，所以我们用另一个辅助栈来保存每个状态对应的最小值，就可以实现O(1)复杂度内获取栈的最小值。

这里还可以优化的一个点是对于栈的每次操作都不一定将栈最小值压入辅助栈中，只要主栈的操作不影响栈的最小值，我们就可以不用对辅助栈进行更新。

.play interview/offer/30.go

# 面试题31. 栈的压入、弹出序列

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。

### 示例1:

```
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
```

### 示例2:

```
输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出。
```

### 提示:

```
0 <= pushed.length == popped.length <= 1000
0 <= pushed[i], popped[i] < 1000
pushed 是 popped 的排列
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof

## Solution

比较容易想到的是用一个栈来模拟压入弹出，用两个指针来表示操作栈在当前压入弹出序列的位置，然后依次模拟判断。

如果压入序列全部压入也不能满足栈顶元素是输出序列的下一个元素，即可否定。

.play interview/offer/31.go

# 面试题32-I. 从上到下打印二叉树

从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。

例如:

```
给定二叉树: [3,9,20,null,null,15,7],

  3
 / \
9  20
  /  \
 15   7
```

返回：

```
[3,9,20,15,7]
```

提示：

```
节点总数 <= 1000
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof

## Solution

二叉树的层次遍历，很容易想到使用队列来解决，遍历节点后先将左子节点加入队列，再将右子节点加入队列。

.play interview/offer/32-1.go

# 面试题32-II. 从上到下打印二叉树II

从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。

例如:

```
给定二叉树: [3,9,20,null,null,15,7],

  3
 / \
9  20
  /  \
 15   7
```

返回其层次遍历结果：

```
[
  [3],
  [9,20],
  [15,7]
]
```

### 提示:

```
节点总数 <= 1000
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof

## Solution

相比上一题多了个步骤，就是处理节点时把每层的节点分离出来。

.play interview/offer/32-2.go

# 面试题32-III. 从上到下打印二叉树III

请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。

例如:

```
给定二叉树: [3,9,20,null,null,15,7],

  3
 / \
9  20
  /  \
 15   7
```

返回其层次遍历结果：

```
[
  [3],
  [20,9],
  [15,7]
]
```

### 提示:

```
节点总数 <= 1000
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof

## Solution

在上一题的基础上又增加一步，统计当前层数是否反转，如果反转则反序写入结果。

.play interview/offer/32-3.go

# 面试题33. 二叉搜索树的后序遍历序列

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。

```
参考以下这颗二叉搜索树：

     5
    / \
   2   6
  / \
 1   3
```

### 示例1:

```
输入: [1,6,3,2,5]
输出: false
```

### 示例2:

```
输入: [1,3,2,6,5]
输出: true
```

### 提示:

```
数组长度 <= 1000
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof

## Solution

对于后续遍历，根节点一定是序列的最后节点，同时根节点前包含左子树和右子树，左子树的节点一定比根节点小，右子树的节点一定逗比根节点大。
以此规律做递归验证即可。

.play interview/offer/33.go

# 面试题34. 二叉树中和为某一值的路径

输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。

### 示例:

```
给定如下二叉树，以及目标和 sum = 22，

      5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1
```

返回:

```
[
   [5,4,11,2],
   [5,8,4,5]
]
```

### 提示:

```
节点总数 <= 10000
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof

## Solution

由于定义了路径是从根到叶子节点，使用递归查找即可，因为值有可能出现负数，所以不能做剪枝。

.play interview/offer/34.go

# 面试题35. 复杂链表的复制

请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。

### 示例1:

.image /content/img/interview/offer/35-1.png 0 700

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

### 示例2:

.image /content/img/interview/offer/35-2.png 0 700

```
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
```

### 示例 3:

.image /content/img/interview/offer/35-3.png 0 700

```
输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
```

### 示例 4:

```
输入：head = []
输出：[]
解释：给定的链表为空（空指针），因此返回 null。
```

### 提示:

```
-10000 <= Node.val <= 10000
Node.random 为空（null）或指向链表中的节点。
节点数目不超过 1000 。
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof

## Solution

1. 在原链表每个节点后都复制一个节点并插入到该节点后
2. 遍历链表，将复制的节点的Random指针后移（Random不为nil的情况下），这样就是实现了复制Random指针
3. 接下来只要分离原链表和复制的链表即可

.play interview/offer/35.go

# 面试题36. 二叉搜索树与双向链表

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

为了让您更好地理解问题，以下面的二叉搜索树为例：
 
.image /content/img/interview/offer/36-1.png 0 400

我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。

下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。

.image /content/img/interview/offer/36-2.png 0 500

特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof

## Solution

1. 对于二叉搜索树，中序遍历可以得到有序结果。
2. 所以在遍历过程中寻找链表head节点，同时更新pre表示上一个节点。
3. pre不为nil时更新 pre.Right = current; current.Left = pre
4. 遍历结束后pre就是尾节点，head就是头结点，最后把头尾相连即可

.play interview/offer/36.go

# 面试题37. 序列化二叉树

请实现两个函数，分别用来序列化和反序列化二叉树。

### 示例: 

```
你可以将以下二叉树：

    1
   / \
  2   3
     / \
    4   5

序列化为 "[1,2,3,null,null,4,5]"
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof

## Solution

如果要实现一个工业级的序列化方法，一个基本要求是从数据流中读取数据的时候就开始序列化，而不是等待所有数据都到达后才开始。

如果二叉树序列化从根节点开始，就可以满足刚刚的要求，所以可以根据前序遍历的顺序来序列化二叉树。对于序列化后的叶节点，它之后会跟着两个'null'。

.play interview/offer/37.go

# 面试题38. 字符串的排列

输入一个字符串，打印出该字符串中字符的所有排列。

你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

### 示例:

```
输入：s = "abc"
输出：["abc","acb","bac","bca","cab","cba"]
```

### 限制:

```
1 <= s 的长度 <= 8
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof

## Solution

使用搜索的方式，但是要注意去重，除了用set去重以外，还可以在搜索中跳过前面已经填过的字符实现。

.play interview/offer/38.go

# 面试题39. 数组中出现次数超过一半的数字

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

### 示例1:

```
输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]
输出: 2
```

### 限制:

```
1 <= 数组长度 <= 50000
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof

## Solution

摩尔投票法，遍历计数

.play interview/offer/39.go

# 面试题40. 最小的k个数

输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

### 示例1:

```
输入：arr = [3,2,1], k = 2
输出：[1,2] 或者 [2,1]
```

### 示例2:

```
输入：arr = [0,1,2,1], k = 1
输出：[0]
```

### 限制:

```
0 <= k <= arr.length <= 10000
0 <= arr[i] <= 10000
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof

## Solution

对于TopK问题，通常考虑到用堆，这里维护一个大顶堆，遍历数组，遇到比堆顶小的数时替换堆顶并堆化。

.play interview/offer/40.go

# 面试题41. 数据流中的中位数

如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。

例如，

[2,3,4] 的中位数是 3

[2,3] 的中位数是 (2 + 3) / 2 = 2.5

设计一个支持以下两种操作的数据结构：

void addNum(int num) - 从数据流中添加一个整数到数据结构中。

double findMedian() - 返回目前所有元素的中位数。

### 示例1:

```
输入：
["MedianFinder","addNum","addNum","findMedian","addNum","findMedian"]
[[],[1],[2],[],[3],[]]

输出：
[null,null,null,1.50000,null,2.00000]
```

### 示例2:

```
输入：
["MedianFinder","addNum","findMedian","addNum","findMedian"]
[[],[2],[],[3],[]]

输出：
[null,null,2.00000,null,2.50000]
```

### 限制:

```
最多会对 addNum、findMedia进行 50000 次调用。
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof

## Solution

- 维护一个大顶堆和一个小顶堆，始终保持 size(小顶堆) >= size(大顶堆)+1 。
- 每添加一个数，先加入大顶堆，再把大顶堆堆顶加入小顶堆，如果大顶堆数比小顶堆多2个，就再取大顶堆堆顶加入小顶堆。

.play interview/offer/41.go

# 面试题42. 连续子数组的最大和

输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

### 示例1:

```
输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

### 提示:

```
1 <= arr.length <= 10^5
-100 <= arr[i] <= 100
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof

## Solution

1. 贪心

遍历数组，并统计和，如果遍历到某个位置时统计和比当前数还要小，那前面的数组就相当于"拖后腿了"，没必要使用了。

2. 动态规划

使用动态规划，dp[i] 表示以 nums[i] 为结尾的最大子数组和，

```
dp[i] = dp[i-1] <= 0 ？nums[i]  : dp[i-1] + nums[i]
```

.play interview/offer/42-1.go
.play interview/offer/42-2.go

# 面试题43. 1～n整数中1出现的次数

输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。

例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。

### 示例1:

```
输入：n = 12
输出：5
```

### 示例2:

```
输入：n = 13
输出：6
```

### 限制:

```
1 <= n < 2^31
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof

## Solution

todo

.play interview/offer/43.go

# 面试题44. 数字序列中某一位的数字

数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。

请写一个函数，求任意第n位对应的数字。


### 示例1:

```
输入：n = 3
输出：3
```

### 示例2:

```
输入：n = 11
输出：0
```

### 限制:

```
0 <= n < 2^31
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof

## Solution

通过分析规律可以发现，不同位数所占的串长度是有规律的，9 * 1、90 * 2、 900 * 3 ...
- 先求出n处于多少位数的数的区间
- 通过减去前面的基数就能算出是哪个数了
- 最后就是求n在这个数字符串中的哪个数

.play interview/offer/44.go

# 面试题45. 把数组排成最小的数

输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。

### 示例1:

```
输入: [10,2]
输出: "102"
```

### 示例2:

```
输入: [3,30,34,5,9]
输出: "3033459"
```

### 提示:

```
0 < nums.length <= 100
```

### 说明:

```
输出结果可能非常大，所以你需要返回一个字符串而不是整数
拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof

## Solution

本质还是排序，但是我们最后需要组成最小的字符排列。所以排序的比较方法应该比较两个字符串如何排列使得结果最小。

.play interview/offer/45.go

# 面试题46. 把数字翻译成字符串

给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。


### 示例1:

```
输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"
```

### 提示:

```
0 <= num < 231
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof

## Solution

从后往前一次取两位数比较，如果最后两位数处于[10,25]，就表示有两种表示法，可以单独编码一个数字（截掉最后一位）或编码两个数字（截掉最后两位）。于是问题就可以分解为子问题递归求解了

.play interview/offer/46.go

# 面试题47. 礼物的最大价值

在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？

### 示例1:

```
输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 12
解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物
```

*### 提示:*

```
0 < grid.length <= 200
0 < grid[0].length <= 200
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof

## Solution

两种思路，一种是递归回溯，另一种是动态规划，动态规划效率更高。

使用滚动数组的技巧，将dp数组优化，转移方程也比较好理解，即每次选择左边或上边更大的礼物值。

.play interview/offer/47.go

# 面试题48. 最长不含重复字符的子字符串

请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。

### 示例1:

```
输入: "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

### 示例2:

```
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

### 示例3:

```
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

### 提示:

```
s.length <= 40000
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof

## Solution

todo

.play interview/offer/48.go

# 面试题49. 丑数

我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

### 示例:

```
输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
```

### 说明:  

```
1 是丑数。
n 不超过1690。
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/chou-shu-lcof

## Solution

todo

.play interview/offer/49.go

# 面试题50. 第一个只出现一次的字符

在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。

### 示例1:

```
s = "abaccdeff"
返回 "b"
```

### 示例2:

```
s = ""
返回 " "
```

### 限制:

```
0 <= s 的长度 <= 50000
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof

## Solution

s只包含小写字母，用一个数组保存a-z的计数，遍历两次即可。

.play interview/offer/50.go

# 面试题51. 数组中的逆序对

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

### 示例1:

```
输入: [7,5,6,4]
输出: 5
```

### 限制:

```
0 <= 数组长度 <= 50000
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof

.play interview/offer/51.go

# 面试题52. 两个链表的第一个公共节点

输入两个链表，找出它们的第一个公共节点。

如下面的两个链表：

.image /content/img/interview/offer/52-1.png 0 400

在节点 c1 开始相交。

.image /content/img/interview/offer/52-2.png 0 400

### 示例1:

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5],
  skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。
 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。
 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

### 示例2:

.image /content/img/interview/offer/52-3.png 0 400

```
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4],
  skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。
 从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。
 在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

### 示例3:

.image /content/img/interview/offer/52-4.png 0 400

```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5],
  skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，
而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。
```

*注意：*

```
如果两个链表没有交点，返回 null.
在返回结果后，两个链表仍须保持原有的结构。
可假定整个链表结构中没有循环。
程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof

## Solution

先遍历两次链表，获得长度lenA，lenB。因为链表后续节点相同，准备两个指针开始遍历两个链表，先让较长的指针走 abs（lenA - lenB） 步，再两个指针同时走，走到第一个相同的节点则为相交点。

.play interview/offer/52.go

# 面试题53-I. 在排序数组中查找数字 I

统计一个数字在排序数组中出现的次数。

### 示例1:

```
输入: nums = [5,7,7,8,8,10], target = 8
输出: 2
```

### 示例2:

```
输入: nums = [5,7,7,8,8,10], target = 6
输出: 0
```

### 限制:

```
0 <= 数组长度 <= 50000
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof

## Solution

看到有序数组的查找应首先想到二分查找法，此题可分解为两次二分查找，第一次查找第一个值为给定值的元素，第二次查找最后一个值为给定值的元素。

.play interview/offer/53-1.go

# 面试题53-II. 0～n-1中缺失的数字

一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

### 示例1:

```
输入: [0,1,3]
输出: 2
```

### 示例2:

```
输入: [0,1,2,3,4,5,6,7,9]
输出: 8
```

### 限制:

```
1 <= 数组长度 <= 10000
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof

## Solution

看到有序数组会想到用二分法，而分区条件就是判断中位点的数是否在正确的位置上。

查找唯一的数还可以考虑用位运算的异或法，因为每个数字范围在0~n-1内，数组下标的范围也在0~n-1内。

.play interview/offer/53-2-bs.go
.play interview/offer/53-2-xor.go

# 面试题54. 二叉搜索树的第k大节点

给定一棵二叉搜索树，请找出其中第k大的节点。

### 示例1:

```
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 4
```

### 示例2:

```
输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 4
```

### 限制:

```
1 ≤ k ≤ 二叉搜索树元素个数
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof

.play interview/offer/54.go

# 面试题55-I. 二叉树的深度

输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。

例如：

```
给定二叉树 [3,9,20,null,null,15,7]，

    3
   / \
  9  20
    /  \
   15   7
返回它的最大深度 3 。
```

### 提示:

```
节点总数 <= 10000
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof

.play interview/offer/55-1.go

## Solution

二叉树的深度是它的左右子树的最大深度加1，因此可以通过递归的方式求解。

# 面试题55-II. 平衡二叉树

输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

### 示例1:

```
给定二叉树 [3,9,20,null,null,15,7]

    3
   / \
  9  20
    /  \
   15   7
返回 true 。
```

### 示例2:

```
给定二叉树 [1,2,2,3,3,null,null,4,4]

       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
返回 false 。
```

### 限制:

```
1 <= 树的结点个数 <= 10000
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof

## Solution

本质其实是和上一题类似，通过判断左右子树的深度差是否小于2来判定树书否平衡，如果左右子树平衡，需要继续对左右子树分别判断。

用递归的方式可以轻松的实现出来，但是有更加优化的方法吗？

.play interview/offer/55-2.go

# 面试题56-I. 数组中数字出现的次数

一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

### 示例1:

```
输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]
```

### 示例2:

```
输入：nums = [1,2,10,4,1,4,3,3]
输出：[2,10] 或 [10,2]
```

### 限制:

```
2 <= nums <= 10000
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof

## Solution

```
时间复杂度：O(n)
空间复杂度：O(1)
```

首先我们知道用异或可以实现不使用变量交换两个整型数或找到一个成对整型数组中只出现一次的数。

这道题的思路也类似，由于数组中出现了两个不同的数，遍历异或的最后结果就是这两个数的异或结果，并且一定不为0。

于是问题就在于如何分离这两个不同的数，根据异或的概念，异或结果为1的位表示两数在该位上不同。所以就能把数组中该位上为1的和为0的分开，分别进行遍历异或，最后得到的就是两个分离的数了。

.play interview/offer/56-1.go

# 面试题56-II. 数组中数字出现的次数 II

在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。

### 示例1:

```
输入：nums = [3,4,3,3]
输出：4
```

### 示例2:

```
输入：nums = [9,1,7,9,7,9,7]
输出：1
```

### 限制:

```
1 <= nums.length <= 10000
1 <= nums[i] < 2^31
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof

.play interview/offer/56-2.go

# 面试题57. 和为s的两个数字

输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。

### 示例1:

```
输入：nums = [2,7,11,15], target = 9
输出：[2,7] 或者 [7,2]
```

### 示例2:

```
输入：nums = [10,26,30,31,47,60], target = 40
输出：[10,30] 或者 [30,10]
```

### 限制:

```
1 <= nums.length <= 10^5
1 <= nums[i] <= 10^6
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof

## Solution

```
时间复杂度：O(n)
空间复杂度：O(1)
```

使用双指针的办法，因为输入序列是有序的，每次计算 sum = nums[lo] + nums[hi]:

- 如果 sum < target : 增大 lo
- 如果 sum > target : 减小 hi
- 如果 sum = target : 找到，返回

.play interview/offer/57-1.go

# 面试题57-II. 和为s的连续正数序列

输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。

序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

### 示例1:

```
输入：target = 9
输出：[[2,3,4],[4,5]]
```

### 示例2:

```
输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]
```

### 限制:

```
1 <= target <= 10^5
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof

## Solution

与上一题类似，准备两个指针 lo 和 hi，用来表示区间。因为区间最小为2，需要满足输入大于2，且 hi 最大为 (target + 1) / 2

- 开始时，lo = 1， hi = 2，sum = 3
- sum = target : 记录结果，hi后移
- sum < target : sum加上区间外最小的数hi+1，hi后移
- sum > target : sum减去最小的数lo，lo后移
- 直到 hi > (target + 1) / 2 结束

.play interview/offer/57-2.go

# 面试题58-I. 翻转单词顺序

输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student. "，则输出"student. a am I"。

### 示例1:

```
输入: "the sky is blue"
输出: "blue is sky the"
```

### 示例2:

```
输入: "  hello world!  "
输出: "world! hello"
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
```

### 示例3:

```
输入: "a good   example"
输出: "example good a"
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
```

### 说明:

```
无空格字符构成一个单词。
输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof

## Solution

```
时间复杂度 : O(n)
空间复杂度 : O(1)
```

先处理字符串前后和中间的空格，再对字符串做反转处理。

.play interview/offer/58-1.go

# 面试题58-II. 左旋转字符串

字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

### 示例1:

```
输入: s = "abcdefg", k = 2
输出: "cdefgab"
```

### 示例2:

```
输入: s = "lrloseumgh", k = 6
输出: "umghlrlose"
```

### 限制:

```
1 <= k < s.length <= 10000
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof

## Solution

实际上是上一题反转函数的拓展，其实只需要调用 reverse() 三次即可。

.play interview/offer/58-2.go

# 面试题59-I. 滑动窗口的最大值

给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。

### 示例:

```
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7]
解释:

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

### 提示:

```
你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof

## Solution

用一个双端队列来保存滑动窗口的最大值，由于要考虑到最大值滑出窗口的可能，所以队列中保存数值在数组中的下标。

开始扫描输入数组，每个元素从队尾开始入队，入队时为了保证顺序，需要不断删除队尾中比小于等于入队元素的元素。

因为元素从队尾滑入，所以每次只需要判断一次队头元素是否已经滑出即可。

.play interview/offer/59-1.go

# 面试题59-II. 队列的最大值

请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的时间复杂度都是O(1)。

若队列为空，pop_front 和 max_value 需要返回 -1

### 示例1:

```
输入:
["MaxQueue","push_back","push_back","max_value","pop_front","max_value"]
[[],[1],[2],[],[],[]]
输出: [null,null,null,2,1,2]
```

### 示例2:

```
输入:
["MaxQueue","pop_front","max_value"]
[[],[],[]]
输出: [null,-1,-1]
```

### 限制:

```
1 <= push_back,pop_front,max_value的总操作数 <= 10000
1 <= value <= 10^5
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof

## Solution

解题思路与上一题类似：当一个比队列中所有元素都大的元素入队时，队列中所有元素（也就是这个元素之前的元素）都不会成为最大值；但是当较小的元素入队时，因为比他大的元素会在他之前先出队，之后它就有可能成为最大元素，所以我们需要将它保存。

.play interview/offer/59-2.go

# 面试题60. n个骰子的点数

把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。

你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。

### 示例1:

```
输入: 1
输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]
```

### 示例2:

```
输入: 2
输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,
   0.11111,0.08333,0.05556,0.02778]
```

### 限制:

```
1 <= n <= 11
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof

## Solution

如果使用递归投骰子的方式，仔细分析我们会发现其中存在重复计算。

使用动态规划可以减少重复计算，dp[i][j] = val，其中i表示投的第i个骰子，j表示所有可能的点数和（范围i~6*i），val则表示出现的次数。

于是可以得到状态转移方程如下

```
dp[i][j] = dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-k] // 1 <= k <= 6 且 j-k > 0
```

.play interview/offer/60.go

# 面试题61. 扑克牌中的顺子

从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。

### 示例1:

```
输入: [1,2,3,4,5]
输出: True
```

### 示例2:

```
输入: [0,0,1,2,5]
输出: True
```

### 限制:

```
数组长度为 5 
数组的数取值为 [0, 13]
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof

## Solution

数组长度固定为5，根据规则，数字之间的空缺可以用0去补，那么我们主要做三步

- 将数组排序
- 统计数组中0的个数
- 统计数组中空缺的个数
- 比较即可得出结果

.play interview/offer/61.go

# 面试题62. 圆圈中最后剩下的数字

0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

### 示例1:

```
输入: n = 5, m = 3
输出: 3
```

### 示例2:

```
输入: n = 10, m = 17
输出: 2
```

### 限制:

```
1 <<= n <= 10^5
1 = m <= 10^6
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof

## Solution

```
时间复杂度：O(n)
空间复杂度：O(1)
```

本题实际上是经典的[[https://baike.baidu.com/item/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98][约瑟夫问题]]，因此最先想到的是使用数据结构中的循环链表来模拟解题过程。

但是如果我们通过分析 n 与 m 的关系，同样也能求解，我们把 f(n, m) 记为最后剩下的数字。

在 n 个数字中，第一个被删除的数 k 是 (m-1)%n ，之后的数从 k+1 开始排列。而根据新的排列数组小标到数字建立的映射可描述为：

```
y = (x + k + 1) % n
```

而对n-1个数字，不断删除第m个数字后的结果是 f(n-1, m)，使用上边的公式就可表示为

```
f(n, m) =（f(n−1, m) + k + 1) % n
k = (m - 1) % n
```

根据 `(a % n + b) % n = (a + b) % n` 所以将k带入，用递推公式可表示为

```
n = 1 : f(n, m) = 0
n > 1 : f(n, m) = [f(n-1, m) + m ] % n
```

.play interview/offer/62-recursion.go
.play interview/offer/62-for.go

# 面试题63. 股票的最大利润

假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？

### 示例1:

```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，
  最大利润 = 6-1 = 5 。
      注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
```

### 示例2:

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

### 限制:

```
0 <= 数组长度 <= 10^5
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof

## Solution

要获得最大利润，就需要我们在股票价格最低点买入，最高点卖出。类似贪心策略，只要一次遍历。

维护两个变量，一个是过去的股票最低价格，一个是有可能获得的最高利润，在遍历过程中更新。

.play interview/offer/63.go

# 面试题64. 求1+2+…+n

求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

### 示例1:

```
输入: n = 3
输出: 6
```

### 示例2:

```
输入: n = 9
输出: 45
```

### 限制:

```
1 <= n <= 10000
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/qiu-12n-lcof

## Solution

主要是利用语言特性如短路求值法来解决，此题没有实际意义。

.play interview/offer/64.go

# 面试题65. 不用加减乘除做加法

写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。

### 示例:

```
输入: a = 1, b = 1
输出: 2
```

### 提示:

```
a, b 均可能是负数或 0
结果不会溢出 32 位整数
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof

## Solution

不能使用加减乘除，就应该想到使用位运算操作，类似十进制加法步骤：

- 先不考虑进位将两个二进制数相加，这得到的结果与 异或运算 相同
- 再考虑进位，只有两个位都为1才会发生进位，结果与 与运算 相同
- 于是我们将 不考虑进位相加的数 与 需要进位的数（需要左移加到高位上） 相加，直到 需要进位的数 为0

.play interview/offer/65.go

# 面试题66. 构建乘积数组

给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。

### 示例:

```
输入: [1,2,3,4,5]
输出: [120,60,40,30,24]
```

### 提示:

```
所有元素乘积之和不会溢出 32 位整数
a.length <= 100000
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof

## Solution

```
时间复杂度：O(n)
空间复杂度：O(1)
```

通过把b看成一个主对角线上的元素都为1的矩阵，b[i]就是矩阵中第i行的乘积。

实现过程中可以分两个步骤，先计算A[0]*...*A[i-1]，再计算A[i+1]*...*A[n-1]。

.play interview/offer/66.go

# 面试题67. 把字符串转换成整数

写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。

首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。

当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。

该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。

注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。

在任何情况下，若函数不能进行有效的转换时，请返回 0。

### 说明:

假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。

### 示例1:

```
输入: "42"
输出: 42
```

### 示例2:

```
输入: "   -42"
输出: -42
解释: 第一个非空白字符为 '-', 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
```

### 示例3:

```
输入: "4193 with words"
输出: 4193
解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
```

### 示例4:

```
输入: "words and 987"
输出: 0
解释: 第一个非空字符是 'w', 但它不是数字或正、负号。
     因此无法执行有效的转换。
```

### 示例5:

```
输入: "-91283472332"
输出: -2147483648
解释: 数字 "-91283472332" 超过 32 位有符号整数范围。
     因此返回 INT_MIN (−231) 。
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof

## Solution

总体来说中规中矩，就是需要注意到各类边界值。

.play interview/offer/67.go

# 面试题68-I. 二叉搜索树的最近公共祖先

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]

.image /content/img/interview/offer/68-1.png 0 300

### 示例1:

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6
解释: 节点 2 和节点 8 的最近公共祖先是 6。
```

### 示例2:

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2,
  因为根据定义最近公共祖先节点可以为节点本身。
```

说明:

```
所有节点的值都是唯一的。
p、q 为不同节点且均存在于给定的二叉搜索树中。
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof

## Solution

todo

.play interview/offer/68-1.go

# 面试题68-II. 二叉树的最近公共祖先

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]

.image /content/img/interview/offer/68-2.png 0 300
 
### 示例1:

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
```

### 示例2:

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。
  因为根据定义最近公共祖先节点可以为节点本身。
```

说明:

```
所有节点的值都是唯一的。
p、q 为不同节点且均存在于给定的二叉树中。
```

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof

## Solution

todo

.play interview/offer/68-2.go
