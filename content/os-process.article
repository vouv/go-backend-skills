进程与线程
进程、线程、协程

Vouv
https://github.com/vouv

# 进程

定义：进程是指一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。

.image /content/img/os/process-1.jpg 0 500

*进程的组成*

进程包含了正在运行的一个程序的 `所有状态` 信息，在内核中以进程控制块PCB维护。

- 代码
- 数据
- 状态寄存器：CPU状态CR0、指令指针IP
- 通用寄存器：AX、BX、CX...
- 占用的系统资源：打开的文件、分配的内存

*进程的特点*

- 动态性：可动态创建、结束
- 并发性：进程可以被独立调度并占用处理机运行
- 独立性：不同的进程的工作互不影响
- 制约性：引访问共享数据/资源或进程间同步而产生制约

.image /content/img/os/process-2.jpg 0 500

*进程与程序的联系*

- 进程是操作系统处于执行状态程序的抽象
	- 程序 = 文件（静态的可自行文件）
	- 进程 = 执行中的程序 = 程序 + 执行状态
- 同一个程序的多次执行过程对应为不同进程
- 进程执行需要资源
	- 内存：保存代码和数据
	- CPU：执行指令

*进程与程序的区别*

- 进程是动态的，程序是静态的
	程序是有序代码的集合
	进程是程序的执行，进程有核心态/用户态
- 进程是暂时的，程序是永久的
	进程是一个状态变化的过程
	程序可长久保存
- 进程和程序组成不同
	进程的组成包括程序、数据和进程控制块

# 进程控制块（PCB）

PCB（Process Control Block）：操作系统管理控制进程运行所用的信息集合。

- 操作系统用PCB来描述进程的基本状况以及运行变化的过程
- PCB是进程存在的唯一标识

*进程控制块*

进程标识信息、处理机现场保存、进程控制信息

	PC：当前指令指针
	SP：栈顶
	其他寄存器
	PID
	UID
	调度优先级
	打开文件列表
	...

*进程控制信息*

- 调度和状态信息
- 进程间通信信息
- 存储管理信息
- 进程所用资源
- 有关数据结构连接信息：与PCB相关的进程队列

*PCB的组织*

- 链表：同一状态的PCB组成链表，多个状态对于多个链表（如就绪，等待）
- 索引表：同一状态的进程归入一个索引表

.image /content/img/os/pcb-1.jpg 0 500

# 进程状态

进程的生命周期：创建、执行、等待、抢占、唤醒、结束。

*进程创建*

引起进程创建的情况

- 系统初始化时
- 用户请求创建一个新进程
- 正在运行的进程执行了创建进程的系统调用

*进程执行*

内核选择一个就绪状态的进程来执行，选择方法：处理机的调度算法、

*进程等待*

只有进程自身才知道何时需要等待某种事件发生，进入等待（阻塞）的情况

- 请求并等待系统服务后，无法马上完成
- 启动某种操作，无法马上完成
- 需要的数据没有到达

*进程抢占*

被抢占的情况

- 高优先级进程就绪
- 进程执行时间片用完

*进程唤醒*

进程只能被别的进程或者操作系统唤醒，进程唤醒的情况

- 被阻塞进程需要的资源可被满足
- 被阻塞进程等待的事件到达

*进程结束*

进程结束的情况

- 正常退出（自愿的）
- 错误退出（自愿的）
- 致命错误（强制性）
- 其他进程所杀（强制性）

# 三状态进程模型

在整个进程运行的生命周期中核心的状态是就绪、等待和运行。

.image /content/img/os/process-model.jpg 0 500

- 运行状态（Running）：正在处理机上运行
- 就绪状态（Ready）：进程获得除处理机之外的所需资源，得到处理机即可运行
- 等待状态（又称阻塞状态Blocked）：等待某一事件出现而暂停运行

辅助状态

- 创建状态（New）：一个进程正在被创建，还没转到就绪状态的状态
- 结束状态（Exit）：一个进程正在从系统中消失时的状态

*nil*->*创建*

一个新进程被创建用于执行一个程序。

*创建*->*就绪*

当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态。

*就绪*->*运行*

处于就绪状态的进程被进程调度程序选中，就分配到处理机上运行。

*运行*->*结束*

当进程表示它已经完成或者因出错，进程会由操作系统结束处理。

*运行*->*就绪*

处于运行状态的进程在其运行的过程中，由于分配给它的处理机时间片用完而让出处理机。

*运行*->*等待*

当进程请求某资源且必须等待时。

*等待*->*就绪*

进程等待的事件到达，它由阻塞状态变为就绪状态。

# 挂起进程模型

处于挂起状态的进程映像再磁盘上，目的是减少进程占用内存。

.image /content/img/os/process-hang-up.jpg 0 500

*等待挂起状态（Blocked-suspend）*

进程在外存并等待某事件出现

*就绪挂起状态（Ready-suspend）*

进程在外存，但只要进入内存即可运行。原因：进程优先级不高或内存不够。

*挂起（Suspend）*

把进程从内存转到外存。

- 等待到等待挂起：没有进程处于就绪状态或就绪进程要求更多内存资源
- 就绪到就绪挂起：当有高优先级等待（系统认为会很快就绪的）进程和低优先级就绪进程
- 运行到就绪挂起：对抢先式分时系统，当有高优先级等待挂起进程因时间出现而进入就绪挂起

*激活（Active）*

把进程从外存转到内存。

- 就绪挂起到就绪
- 等待挂起到等待

*状态队列*

操作系统维护一组队列。表示系统中所有进程的当前状态。根据状态的不同，进程PCB会加入到对应的队列。

.image /content/img/os/process-hang-up-2.jpg 0 500

# 线程概念

*为什么引入线程*

并发的多进程实现，进程创建、进程结束和进程切换的系统开销大。

在进程间增加实体，使得实体可以并发运行，并且共享资源。

*线程概念*

	线程 = 进程 - 共享资源

线程是进程的一部分，描述指令流执行的状态，它是进程中的指令流的最小单元，是CPU调度的基本单位。

- 进程的资源分配角色：进程由一组相关资源构成，包括地址空间（代码段、数据段）、打开的文件等各种资源
- 线程的处理机调度角色：线程描述在进程资源环境中的指令执行流状态

线程优点

- 一个进程中可以同时存在多个线程
- 各个线程可以并发运行
- 各个线程可以共享地址空间和文件等资源

线程缺点

- 一个线程崩溃，会导致所属进程的所有线程崩溃

.image /content/img/os/thread-1.jpg 0 500

线程与进程比较

- 进程是资源分配单位，线程是CPU调度单位
- 进程拥有完整资源，线程只独享指令流执行的必要资源如寄存器或栈
- 线程具有就绪、等待和运行三种基本状态和状态间转换关系
- 线程能减少并发执行的时间和空间开销
	线程的创建时间比进程短
	线程的终止时间比进程短
	同一进程内的线程切换时间比进程切换短
	由于同一进程的各线程共享内存和文件资源，可不通过内核进行直接通信

*线程的实现方式*

- 用户线程：在用户空间实现（POSIX Pthreads，Mach C-threads、Solaris threads）
- 内核线程：在内核中实现（Windows、Solaris、Linux）
- 轻量级线程：在内核中实现、支持用户线程（Goroutine）

# 用户线程

由一组用户级的线程库函数来完成线程管理，包括线程创建、终止、同步和调度等。

.image /content/img/os/user-thread-1.jpg 0 500

*用户线程特征*

不依赖操作系统内核

- 内核不了解用户线程的存在
- 可用于不支持线程的多进程操作系统

在用户空间实现的线程机制

- 每个进程有私有的线程控制块TCB列表

同一进程内的用户线程切换速度块

- 无需用户态/内核态的切换

允许每个进程拥有自己的线程调度算法


*用户线程不足*

线程发起系统调用而阻塞时，整个进程进入等待

不支持基于线程的处理机抢占

- 除非当前运行进程主动放弃，它所在进程的其他线程无法抢占CPU

线程智能按进程分配CPU时间

- 多个线程进程中，每个线程的时间片较少

# 内核线程

进程由内核通过系统调用实现的线程机制，由内核完成线程的创建、终止和管理。

.image /content/img/os/core-thread-1.jpg 0 500

*内核线程的特征*

- 由内核维护PCB和TCB
- 线程执行系统调用而不阻塞不影响其他线程
- 线程的创建、终止和切换开销相对较大，通过系统调用/内核函数，在内核实现
- 以线程为单位进行CPU时间分配，多线程的进程可获得更多CPU时间

*用户线程和内核线程对应关系*

1. 一对一

.image /content/img/os/core-thread-2.jpg 0 500

2. 多对一

.image /content/img/os/core-thread-3.jpg 0 500

3. 多对多（Golang应用）

.image /content/img/os/core-thread-4.jpg 0 500


# 进程控制

进程切换、进程创建、进程加载、进程等待与退出。

*进程切换（上下文切换）*

- 暂停当前运行进程，从运行状态变成其他状态
- 调度另一个进程从就绪状态变为运行状态

进程切换的要求

- 切换前，保存进程上下文
- 切换后，回复进程上下文
- 快速切换

进程生命周期的信息

- 寄存器（PC、SP...）
- CPU状态
- 内存地址空间

*进程创建*

用户使用系统调用创建新进程，Unix API：fork/exec 。

- fork：把一个进程复制成两个进程
- exec：用新程序来重写当前进程

*fork*

- 复制父进程的所有变量和内存
- 复制父进程的所有CPU寄存器（有特殊的寄存器例外）
- 子进程的fork()返回0
- 父进程的fork()返回子进程标识符
- fork()返回值可方便后续使用，子进程可使用getpid()获取PID

*进程加载*

进程加载和执行系统调用exec()，加载一个完全不同的程序，并从main()函数开始运行。

- 允许进程加载时指定启动参数args
- exec调用后，进程还是相同进程，但是运行了不同程序
- 代码段，堆栈和堆（heap）完全重写

*进程等待与退出*

*进程等待子进程*

wait()系统调用用于父进程等待子进程结束。

- 子进程结束时通过exit()向父进程返回一个值
- 父进程通过wait()接受并处理返回值

*wait()系统调用*

- 子进程存活时，父进程进入等待状态，等待子进程的返回结果
- 子进程调用exit()，会唤醒父进程，exit()的返回值作为父进程wait()的返回结果
- 有僵尸子进程等待时，wait()立即返回其中一个值

*exit()*

进程结束执行调用exit()，完成进程资源回收

exit()功能

- 将调用参数作为进程的"结果"
- 关闭所有打开的文件等资源
- 释放内存
- 释放大部分进程相关的内核数据结构
- 检查父进程是否存活，若存活则保留结果，进入僵尸状态；若不存活则释放所有数据结构
- 清理所有等待的僵尸进程


*其他进程控制系统调用*

- nice()指定进程优先级，Unix系统中进程优先级会随时间衰减
- ptrace()允许一个进程控制另一个进程的执行（也就是调试），设置断点和查看寄存器等
- sleep()可以让进程在定时器的队列中等待指定时间








